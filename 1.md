# Блок 1

## 1. Почему ['R'] === ['R'] === false?

Сравнение на равенство двух разных объектов (в том числе массивов) всегда возвращает false, так как непримитивные типы сравниваются по ссылке.

## 2. Плюсы использования const

Плюсы использования **const/let** в отличии от **var**

- Область видимости — блок. У var область видимости функция.

Пример:

```js
function test() {
  let a = 123

  for (let i = 0; i < 1; i++) {
    let a = 0
    console.log(a)
  }

  console.log(a)
}

test()
```
Выведет в консоль 0, потом 123, так как создались две разые переменные, каждая в отдельной области видимости.

- Если вызвать переменную, объявленную через **const/let** до ее создания, то возникнет ошибка (которая будет видна в консоли), что позволит найти ошибку в коде на более раннем этапе разработки.
- При использовании в цикле, для каждой итерации создаётся своя переменная.

Пример:
```js
function makeArmy() {

  let shooters = []

  for (let i = 0; i < 10; i++) {
    shooters.push(function () {
      console.log(i)
    })
  }

  return shooters
}

const army = makeArmy()

army.forEach((item) => {
  item()
})
```
В консоль выведутся числа от 0 до 9, так как для каждой итерации создаётся своя переменная и, как следствие, на каждой итерации произойдет замыкание для переменной i в функцию, которая добавляется в массив.

**const** в отличии от **let** не позволяет изменять переменную, что позволяет допустить меньше ошибок в коде.

## 3. Что отработает быстрее - setTimeout или Promise. И почему?

Промисы создают микрозадачи, а setTimeout макрозадачи. Микрозадачи выполняются раньше макрозадач. Следовательно, то, что было в обработчике промиса, выполнится раньше, чем то, что было в setTimeout.

## 4. Как прочитать http-only куки?

Только на сервере. Либо в инструментах разработчика.

## 5. Назовите 4 способа применить стили на компонент

- CSS
- Inline-стили
- styled-components
- CSS-модули

## 6. Как предотвратить лишние рендеры у функциональных компонентов?

- Обернуть в memo
- При необходимости обернуть в useCallback и в useMemo передаваемые пропсы
- Создавать стейт и вызывать контекст как можно ниже в дереве компонентов (только там, где они нужны), чтобы лишние рендеры не происходили в компонентах, в которых этот стейт или контекст не используется.

## 7. Минусы использования Context API
- При обновлении значений в контексте происходит рендер всех компонентов, лежащих ниже провайдера контекста в иерархии компонентов.
- Можно нечаянно обратиться не к тому провайдеру (в случае, если компонент обернут в провайдер одного и того же контекста несколько раз)
